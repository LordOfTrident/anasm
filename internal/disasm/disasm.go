package disasm

import (
	"fmt"
	"os"
	"encoding/binary"
	"math"

	"github.com/avm-collection/anasm/internal/compiler"
)

const (
	InstSize = 9
	WordSize = 8
)

type Disassembler struct {
	input []byte
	path  string
	pos   int

	programSize compiler.Word
	entryPoint  compiler.Word

	out string

	noW bool
}

func New(input []byte, path string) *Disassembler {
	return &Disassembler{input: input, path: path}
}

func (d *Disassembler) readBytes(size int) ([]byte, error) {
	var bytes []byte

	end := d.pos + size
	for ; d.pos < end; d.pos ++ {
		if d.pos >= len(d.input) {
			return bytes, fmt.Errorf("'%v' incompatible file format (failed to read %v bytes)",
			                         d.path, size)
		}

		bytes = append(bytes, d.input[d.pos])
	}

	return bytes, nil
}

func (d *Disassembler) readMetadata() error {
	// The 'AVM' string
	magic, err := d.readBytes(3)
	if err != nil {
		return err
	}

	if string(magic) != "AVM" {
		return fmt.Errorf("'%v' is not an AVM executable, %v", d.path, string(magic))
	}

	// AVM version
	version, err := d.readBytes(3)
	if err != nil {
		return err
	}

	if !d.noW {
		if version[0] != compiler.VersionMajor {
			fmt.Fprintf(os.Stderr, "'%v' major version is %v, anasm supported major version is %v",
			            d.path, version[0], compiler.VersionMajor)
		} else if version[1] != compiler.VersionMinor {
			fmt.Fprintf(os.Stderr, "'%v' minor version is %v, anasm supported minor version is %v",
			            d.path, version[1], compiler.VersionMinor)
		}
	}

	bytes, err := d.readBytes(WordSize)
	if err != nil {
		return err
	}
	d.programSize = compiler.Word(binary.BigEndian.Uint64(bytes))

	bytes, err = d.readBytes(WordSize)
	if err != nil {
		return err
	}
	d.entryPoint = compiler.Word(binary.BigEndian.Uint64(bytes))

	return nil
}

func (d *Disassembler) writeInst(name string, data compiler.Word, hasArgument bool) {
	d.out += "\t" + name

	if hasArgument {
		// Argument as int
		d.out += fmt.Sprintf(" %v", uint64(data))

		// Argument as float (in a comment)
		d.out += "\t\t# " + fmt.Sprintf("%v", math.Float64frombits(uint64(data)))
	}

	d.out += "\n"
}

func InstFromOp(op byte) (string, bool, error) {
	for i, v := range compiler.Insts {
		if v.Op == op {
			return i, v.HasArg, nil
		}
	}

	return "", false, fmt.Errorf("Unknown instruction with opcode %i", op)
}

func (d *Disassembler) Disassemble(path string, noW bool) error {
	// Enable warnings?
	d.noW = noW

	// Skip the shebang
	if d.input[d.pos] == '#' {
		for d.input[d.pos] != '\n' {
			d.pos ++
		}

		d.pos ++
	}

	if err := d.readMetadata(); err != nil {
		return err
	}

	d.out += fmt.Sprintf("# Generated by anasm disassembler, supporting AVM v%v.%v\n\n",
	                     compiler.VersionMajor, compiler.VersionMinor)

	// Read and convert instructions
	for i := compiler.Word(0); i < d.programSize; i ++ {
		if i == d.entryPoint {
			d.out += ".entry\n"
		}

		bytes, err := d.readBytes(InstSize)
		if err != nil {
			return err
		}

		name, hasArg, err := InstFromOp(bytes[0])
		if err != nil {
			return err
		}

		data := compiler.Word(binary.BigEndian.Uint64(bytes[1:]))

		d.writeInst(name, data, hasArg)
	}

	// Write the file
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	f.Write([]byte(d.out))

	return nil
}
