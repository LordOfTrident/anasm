package disasm

// TODO: Make the disassembler smarter, use labels instead of literal addresses, detect strings
//       in memory...

import (
	"fmt"
	"os"
	"encoding/binary"
	"math"
	"strings"

	"github.com/avm-collection/anasm/internal/compiler"
)

const (
	InstSize = 9
	WordSize = 8
)

type Disassembler struct {
	input []byte
	path  string
	pos   int

	programSize compiler.Word
	memorySize  compiler.Word
	entryPoint  compiler.Word

	out string

	noW bool
}

func New(input []byte, path string) *Disassembler {
	return &Disassembler{input: input, path: path}
}

func (d *Disassembler) readBytes(size int) ([]byte, error) {
	var bytes []byte

	end := d.pos + size
	for ; d.pos < end; d.pos ++ {
		if d.pos >= len(d.input) {
			return bytes, fmt.Errorf("'%v' incompatible file format (failed to read %v bytes)",
			                         d.path, size)
		}

		bytes = append(bytes, d.input[d.pos])
	}

	return bytes, nil
}

func warn(format string, args... interface{}) {
	fmt.Fprintf(os.Stderr, "Warning: %v", fmt.Sprintf(format, args...))
}

func (d *Disassembler) readMetadata() error {
	// The 'AVM' string
	magic, err := d.readBytes(3)
	if err != nil {
		return err
	}

	if string(magic) != "AVM" {
		return fmt.Errorf("'%v' is not an AVM executable, %v", d.path, string(magic))
	}

	// AVM version
	version, err := d.readBytes(3)
	if err != nil {
		return err
	}

	if !d.noW {
		if version[0] != compiler.VersionMajor {
			warn("'%v' major version is %v, anasm supported major version is %v",
			     d.path, version[0], compiler.VersionMajor)
		} else if version[1] > compiler.VersionMinor {
			warn("'%v' minor version is %v, greater than your supported avm version %v",
			     d.path, version[1], compiler.VersionMinor)
		}
	}

	bytes, err := d.readBytes(WordSize)
	if err != nil {
		return err
	}
	d.programSize = compiler.Word(binary.BigEndian.Uint64(bytes))

	bytes, err = d.readBytes(WordSize)
	if err != nil {
		return err
	}
	d.memorySize = compiler.Word(binary.BigEndian.Uint64(bytes))

	bytes, err = d.readBytes(WordSize)
	if err != nil {
		return err
	}
	d.entryPoint = compiler.Word(binary.BigEndian.Uint64(bytes))

	return nil
}

func (d *Disassembler) writeInst(name string, data compiler.Word, hasArgument bool) {
	d.out += "\t" + name

	if hasArgument {
		// Argument as int
		d.out += fmt.Sprintf(" %v", uint64(data))

		// Argument as float (in a comment)
		d.out += "\t\t# " + fmt.Sprintf("%v", math.Float64frombits(uint64(data)))
	}

	d.out += "\n"
}

func InstFromOp(op byte) (string, bool, error) {
	for i, v := range compiler.Insts {
		if v.Op == op {
			return i, v.HasArg, nil
		}
	}

	return "", false, fmt.Errorf("Unknown instruction with opcode %i", op)
}

func (d *Disassembler) Disassemble(path string, noW bool) error {
	// Enable warnings?
	d.noW = noW

	// Skip the shebang
	if d.input[d.pos] == '#' {
		for d.input[d.pos] != '\n' {
			d.pos ++
		}

		d.pos ++
	}

	if err := d.readMetadata(); err != nil {
		return err
	}

	d.out += fmt.Sprintf("# Generated by anasm disassembler, supporting AVM v%v.%v\n\n",
	                     compiler.VersionMajor, compiler.VersionMinor)

	if err := d.readMemory(); err != nil {
		return err
	}

	if err := d.readInsts(); err != nil {
		return err
	}

	// Write the file
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	f.Write([]byte(d.out))

	return nil
}

func (d *Disassembler) readMemory() error {
	if d.programSize == 0 {
		return nil
	}

	d.out += "let MEM byte ="

	for i := compiler.Word(0); i < d.memorySize; i ++ {
		if i % 8 == 0 {
			d.out += "\n\t"
		}

		bytes, err := d.readBytes(1)
		if err != nil {
			return err
		}

		data := fmt.Sprintf("%v", bytes[0])
		if len(data) < 3 {
			data = strings.Repeat(" ", 3 - len(data)) + data
		}

		d.out += data
		if i + 1 < d.memorySize {
			d.out += ", "
		}
	}

	d.out += "\n\n"

	return nil
}

func (d *Disassembler) readInsts() error {
	// Read and convert instructions
	for i := compiler.Word(0); i < d.programSize; i ++ {
		if i == d.entryPoint {
			d.out += ".entry\n"
		}

		bytes, err := d.readBytes(InstSize)
		if err != nil {
			return err
		}

		name, hasArg, err := InstFromOp(bytes[0])
		if err != nil {
			return err
		}

		data := compiler.Word(binary.BigEndian.Uint64(bytes[1:]))

		d.writeInst(name, data, hasArg)
	}

	return nil
}
