package disasm

import (
	"fmt"
	"os"
	"encoding/binary"
	"math"
	"strings"

	"github.com/avm-collection/anasm/pkg/errors"
	"github.com/avm-collection/anasm/pkg/agen"
	"github.com/avm-collection/anasm/internal/compiler"
)

type Disassembler struct {
	input []byte
	path  string
	pos   int

	programSize agen.Word
	memorySize  agen.Word
	entryPoint  agen.Word

	out string
}

func New(input []byte, path string) *Disassembler {
	return &Disassembler{input: input, path: path}
}

func (d *Disassembler) readBytes(size int) ([]byte, error) {
	var bytes []byte

	end := d.pos + size
	for ; d.pos < end; d.pos ++ {
		if d.pos >= len(d.input) {
			return bytes, fmt.Errorf("'%v' incompatible file format (failed to read %v bytes)",
			                         d.path, size)
		}

		bytes = append(bytes, d.input[d.pos])
	}

	return bytes, nil
}

func (d *Disassembler) readMetadata() {
	// The 'AVM' string
	magic, err := d.readBytes(3)
	if err != nil {
		errors.SimpleError("Failed to read '%v' magic", d.path)
		return
	}

	if string(magic) != "AVM" {
		errors.SimpleError("'%v' is not an AVM executable", d.path)
		return
	}

	// AVM version
	version, err := d.readBytes(3)
	if err != nil {
		errors.SimpleError("Failed to read '%v' version", d.path)
		return
	}

	if version[0] != agen.VersionMajor {
		errors.SimpleWarning("'%v' major version is %v, supported is %v",
		                     d.path, version[0], agen.VersionMajor)
	} else if version[1] > agen.VersionMinor {
		errors.SimpleWarning("'%v' minor version is %v, greater than supported version (%v)",
		                     d.path, version[1], agen.VersionMinor)
	}

	bytes, err := d.readBytes(agen.WordSize)
	if err != nil {
		errors.SimpleError("Failed to read '%v' program size", d.path)
		return
	}
	d.programSize = agen.Word(binary.BigEndian.Uint64(bytes))

	bytes, err = d.readBytes(agen.WordSize)
	if err != nil {
		errors.SimpleError("Failed to read '%v' memory size", d.path)
		return
	}
	d.memorySize = agen.Word(binary.BigEndian.Uint64(bytes))

	bytes, err = d.readBytes(agen.WordSize)
	if err != nil {
		errors.SimpleError("Failed to read '%v' entry point", d.path)
		return
	}
	d.entryPoint = agen.Word(binary.BigEndian.Uint64(bytes))
}

func (d *Disassembler) writeInst(name string, data agen.Word, hasArgument bool) {
	d.out += "\t" + name

	if hasArgument {
		// Argument as int
		d.out += fmt.Sprintf(" %v", uint64(data))

		// Argument as float (in a comment)
		d.out += "\t\t# " + fmt.Sprintf("%v", math.Float64frombits(uint64(data)))
	}

	d.out += "\n"
}

func InstFromOp(op byte) (string, bool, error) {
	for i, v := range compiler.Insts {
		if v.Op == op {
			return i, v.HasArg, nil
		}
	}

	return "", false, fmt.Errorf("Unknown instruction with opcode %v", op)
}

func (d *Disassembler) Disassemble(path string) bool {
	// Skip the shebang
	if d.input[d.pos] == '#' {
		for d.input[d.pos] != '\n' {
			d.pos ++
		}

		d.pos ++
	}

	if d.readMetadata(); errors.Happened() {
		return false
	}

	d.out += fmt.Sprintf("# Generated by ANASM disassembler for AVM v%v.%v\n\n",
	                     agen.VersionMajor, agen.VersionMinor)

	if d.readMemory(); errors.Happened() {
		return false
	}

	if d.readInsts(); errors.Happened() {
		return false
	}

	// Write the file
	f, err := os.Create(path)
	if err != nil {
		errors.SimpleError("Failed to create output file '%v'", path)
		return false
	}
	defer f.Close()

	f.Write([]byte(d.out))

	return true
}

func (d *Disassembler) readMemory() {
	if d.programSize == 0 || d.memorySize < 2 {
		return
	}

	d.out += "let MEM byte ="

	_, _ = d.readBytes(1) // Skip the 0 byte
	for i := agen.Word(0); i < d.memorySize - 1; i ++ {
		if i % 8 == 0 {
			d.out += "\n\t"
		}

		bytes, err := d.readBytes(1)
		if err != nil {
			errors.SimpleError("Failed while reading memory of '%v'", d.path)
		}

		data := fmt.Sprintf("%v", bytes[0])
		if len(data) < 3 {
			data = strings.Repeat(" ", 3 - len(data)) + data
		}

		d.out += data
		if i + 1 < d.memorySize - 1 {
			d.out += ", "
		}
	}

	d.out += "\n\n"
}

func (d *Disassembler) readInsts() {
	// Read and convert instructions
	for i := agen.Word(0); i < d.programSize; i ++ {
		if i == d.entryPoint {
			d.out += ".entry\n"
		}

		bytes, err := d.readBytes(agen.InstSize)
		if err != nil {
			errors.SimpleError("Failed while reading instruction from '%v' at %v", d.path, i)
		}

		name, hasArg, err := InstFromOp(bytes[0])
		if err != nil {
			errors.SimpleError("At %v: %v", i, err.Error())
		}

		data := agen.Word(binary.BigEndian.Uint64(bytes[1:]))

		d.writeInst(name, data, hasArg)
	}
}
